*linux 基本命令
*通配符的使用
*查看帮助文档

**1）重要的快捷键
Tab 进行命令补全、目录、命令参数
ctrl+c 终止当前程序
ctrl+d 键盘输入结束或退出终端
Ctrl+s 暂停当前程序，暂停后按任意键恢复运行
Ctrl+z 将当前程序放到后台运行，恢复到前台命令为 fg
ctrl+a 将光标移至输入行头，相当于home键
Ctrl+e 将光标一直输入行末，相当于End键
Ctrl+k 删除从光标所在位置到行末

**2)学会利用历史输入命令
键盘上 方向 上键 

**3）学会使用通配符
* ?
|字符	 |含义|
|：----|---：|
|*	|匹配 0 或多个字符|
|?	|匹配任意一个字符|
|[list]	|匹配 list 中的任意单一字符|
|[^list]	|匹配 除list 中的任意单一字符以外的字符|
|[c1-c2]	|匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]|
|{string1,string2,...}	|匹配 string1 或 string2 (或更多)其一字符串|
|{c1..c2}	|匹配 c1-c2 中全部字符 如{1..10}|

4)学会在命令行中获取帮助
man 命令 
man <command_name>
man man
man 1 ls 
搜索
/<你要搜索的内容>
搜索结果 用 n 切换
shift + n 为上一个关键词所在 Space 即空格键 翻页 Enter向下滚动一行，k,j(vim编辑器的移动键)向前向后滚动。
h 键显示帮助 q 退出

info命令详细帮助 --help 快速查看具体参数的作用

sudo apt-get update
sudo apt-get install sysvbanner
sudo apt-get install toilet
sudo apt-get install figlet

实验3 用户及文件权限管理
who am i 
who mam likes
查看当前用户的用户名 直接 whoami
who 命令其他常用参数

参数 说明
-a   打印能打印的全部
-d   打印死掉的进程
-m   同am i ,mom likes
-q   打印当前登录用户数及用户名
-u   打印当前登录用户登录信息
-r   打印运行等级

2.1 查看用户
2.2 创建用户
sudo adduser lilei
root账户拥有整个系统至高无上的权利
su su- sudo
su <user> 切换到用户user 
sudo <cmd> 以特权命令级别运行cmd命令
su - <user> 也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量
2.3 用户组
在 Linux 里面如何知道自己属于哪些用户组呢？

方法一：使用 groups 命令
 groups shiyanlou
 回车结果 冒号之前表示用户，后面表示该用户所属的用户组
 
 方法二：查看 /etc/group 文件
  cat /etc/group | sort
  过滤结果
  cat /etc/group | grep -E "shiyanlou"
  /etc/group 文件格式说明
  /etc/group 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：
group_name:password:GID:user_list
 使用 usermod 命令可以为用户添加用户组
sudo usermod -G sudo lilei
删除用户
sudo deluser lilei --remove-home

三、Linux 文件权限
查看文件权限
ls -l
ls -lh 查看文件大小
ls . 当前目录
ls .. 上一级目录
ls -A 查看所有文件 包括隐藏文件
ls -Al
ls -dl 查看目录完整属性
ls -AsSh

3.2 变更文件所有者
sudo chown shiyanlou iphone6

3.3 修改文件权限 
方法一：二进制数字表示
r2w1x0 1*2**2+1*2**1+1*2**0=7
方法二：加减赋值操作
chmod go-rw iphone6
g = groups o = others u = user +-分别表示增加和去掉相应的权限

四、Linux目录结构 文件基本操作
每个目录大体内容
文件的属性
touch file rm mv 等基本命令
目录结构
1、FHS 标准
sudo apt-get update
sudo apt-get install tree
                  可分享的shareable      不可分享的unshareable
不可变的static   /usr 软件放置处         /etc 配置文件
                 /opt 第三方软件         /boot 开机及内核文件
可变动的variable /var/mail 用户邮件信箱 /var/run 程序相关
                 /var/news 新闻组       /var/lock 文件锁相关

2、目录路径
ls -a 查看包括隐藏文件在内的所有文件
- 表示上一次所在目录
～表示当前用户的home目录
pwd 获取当前的绝对路径
cd .. 进入上一级目录
cd ~ 或 cd /home/<你的用户名> 进入你的home目录
以home目录为起点 
cd /usr/local/bin #绝对目录
cd ../../usr/local/bin 相对目录

三、Linux文件的基本操作
1、新建
touch 创建空白文件
mkdir 创建空白目录
mkdir -p father/son/grandson #创建多级目录
touch {1..10}.txt  批量创建文件
2、复制文件
cp test father/son/grandson
复制目录：需要加上 -r 或 -R 表示递归复制，株连九族
cd /home/shiyanlou
mkdir family
cp -r father family
删除文件：rm (remove files or directories)
rm test
删除只读权限的文件：rm -f test

删除目录: rm -r family

4、移动文件与文件重命名
移动文件： mv (move or rename files) mv 源目录文件 目的目录
mkdir Documents
touch file1
mv file1 Documents
重命名文件： mv 旧的文件名 新的文件名
mv file1 myfile
批量重命名： rename 
rename 's/\.txt/\.c/' *.txt  后缀改为.c结尾
rename 'y/a-z/A-Z/' *.c  文件名和后缀名改为大写

5、查看文件
cat 标准输出 正序显示
tac 标准输出 倒序显示 
nl 添加行号并打印
nl 常用的几个参数
-b : 指定添加行号的方式，主要有两种：
    -b a:表示无论是否为空行，同样列出行号("cat -n"就是这种方式)
    -b t:只列出非空行的编号并列出（默认为这种方式）
-n : 设置行号的样式，主要有三种：
    -n ln:在行号字段最左端显示
    -n rn:在行号字段最右边显示，且不加 0
    -n rz:在行号字段最右边显示，且加 0
-w : 行号字段占用的位数(默认为 6 位)
使用more less 命令分页查看文件
more passwd：Enter向下滚动一行，Space向下滚动一屏，h 帮助，q退出
man 手册 vi编辑器

head tail命令查看文件
默认显示头十行和后几行
tail /etc/passwd 新用户的信息在最后一行
tail -n 1 /etc/passwd：只看最后一行
tail -f 不停读取某个文件的内容 实时监视

6、查看文件类型 
file /bin/ls
7、编辑文件
编辑器：emacs、vim、nano
vimtutor 直接使用Linux内部的vim学习教程

Practice 5 环境变量与文件查找
1、环境变量
$ temp=shiyanlou
$ export temp_env=shiyanlou
$ env|sort>env.txt
$ export|sort>export.txt
$ set|sort>set.txt

$ vimdiff env.txt export.txt set.txt

.profile 可以用 ls -a 查看
cd /home/shiyanlou
ls -a 

2. 命令的查找路径与顺序
查看path环境变量的内容
$ echo $PATH
创建shell 脚本
$ cd /home/shiyanlou
$ touch hello_shell.sh
$ gedit hello_shell.sh
添加内容
#!/bin/bash

for ((i=0; i<10; i++));do
    echo "hello shell"
done

exit 0

$ chmod 755 hello_shell.sh

$ cd /home/shiyanlou
$ ./hello_shell.sh
创建一个 C 语言“ hello world ”程序
$ cd /home/shiyanlou
$ gedit hello_world.c

#include <stdio.h>

int main(void)
{
    printf("hello world!\n");
    return 0;
}


$ gcc -o hello_world hello_world.c

$ cd /home/shiyanlou
$ mkdir mybin
$ mv hello_shell.sh hello_world mybin/
运行
$ cd mybin
$ ./hello_shell.sh
$ ./hello_world
3. 添加自定义路径到“ PATH ”环境变量
$ PATH=$PATH:/home/shiyanlou/mybin
$ echo "PATH=$PATH:/home/shiyanlou/mybin" >> .zshrc
上述命令中 >> 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 > 是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。

变量设置方式	说明
${变量名#匹配字串}	从头向后开始匹配，删除符合匹配字串的最短数据
${变量名##匹配字串}	从头向后开始匹配，删除符合匹配字串的最长数据
${变量名%匹配字串}	从尾向前开始匹配，删除符合匹配字串的最短数据
${变量名%%匹配字串}	从尾向前开始匹配，删除符合匹配字串的最长数据
${变量名/旧的字串/新的字串}	将符合旧字串的第一个字串替换为新的字串
${变量名//旧的字串/新的字串}	将符合旧字串的全部字串替换为新的字串
$ path=$PATH
$ echo $path
$ path=${path%/home/shiyanlou/mybin}
# 或使用通配符,*表示任意多个任意字符
$ path=${path%*/mybin}
$ unset temp  #这是变量删除
5、如何让环境变量立即生效
cd /home/shiyanlou
source .zshrc
或 . 命令
$ . ./.zshrc
注意的第一个点后面的空格
三、搜索文件
whereis which find locate
whereis 简单快速
whereis who 
whereis find

locate 快而全
sudo apt-get update
sudo apt-get install locate
locate /etc/sh

locate /usr/share/\*.jpg
统计数目 加上 -c 
忽略大小写 -i 

which 小而精
which man

find 精而细
最强大 find [path] [option][action]
sudo find /etc/ -name interfaces

参数    说明
-atime  最后访问时间
-ctime  最后修改文件内容的时间
-mtime  最后修改文件属性的时间

-mtime n: n为数字，表示在n天之前的“一天之内”修改过的文件
-mtime +n: 列出n天之前（不包含n本身）被修改过的文件件
-mtime -n:列出n天之内（包含n本身）被修改过的文件
-newer file:file为一个已存在的文件，列出比file还要新的文件
$find ~ -mtime 0  #列出home目录，当天（24小时之内）有改动的文件
$find ~ -newer /home/shiyanlou/Code #列出home目录下比Code文件夹新的文件

四、更多
amatrix 
sudo apt-get update;sudo apt-get install cmatrix
cmatrix -C red  #改变代码颜色

Prcatice 6 文件打包与解压缩：zip命令 tar命令 压缩与解压常用组合
文件后缀名	说明
*.zip	zip 程序打包压缩的文件
*.rar	rar 程序压缩的文件
*.7z	7zip 程序压缩的文件
*.tar	tar 程序打包，未压缩的文件
*.gz	gzip 程序（GNU zip）压缩的文件
*.xz	xz 程序压缩的文件
*.bz2	bzip2 程序压缩的文件
*.tar.gz	tar 打包，gzip 程序压缩的文件
*.tar.xz	tar 打包，xz 程序压缩的文件
*tar.bz2	tar 打包，bzip2 程序压缩的文件
*.tar.7z	tar 打包，7z 程序压缩的文件
三、实战
打包文件夹
$ cd /home/shiyanlou
$ zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop
$ du -h shiyanlou.zip
$ file shiyanlou.zip
-r 参数表示递归打包包含子目录的全部内容，-q 参数表示为安静模式，即不向屏幕输出信息，-o，表示输出文件，需在其后紧跟打包输出文件名。后面使用 du 命令查看打包后文件的大小

设置压缩级别为 9 和 1（9 最大，1 最小），重新打包：
$ zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip
$ zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip
 -x 是为了排除我们上一次创建的 zip 文件，否则又会被打包进这一次的压缩文件中，注意：这里只能使用绝对路径，否则不起作用。
 用 du 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小
 $ du -h -d 0 *.zip ~ | sort
 
 创建加密 zip 包
 $ zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop
 为了能够在Windows电脑上顺利解压，需要修正命令
 $ zip -r -l -o shiyanlou.zip /home/shiyanlou/Desktop
 
 3.2 使用 unzip 命令解压缩 zip 文件
将 shiyanlou.zip 解压到当前目录：
$ unzip shiyanlou.zip

使用安静模式，将文件解压到指定目录：
$ unzip -q shiyanlou.zip -d ziptest

上述指定目录不存在，将会自动创建。如果你不想解压只想查看压缩包的内容你可以使用 -l 参数：
$ unzip -l shiyanlou.zip

使用 -O（英文字母，大写 o）参数指定编码类型：
unzip -O GBK 中文压缩文件.zip

3.3 tar 打包工具
创建一个 tar 包：
$ cd /home/shiyanlou
$ tar -P -cf shiyanlou.tar /home/shiyanlou/Desktop
-P 保留绝对路径符，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc shiyanlou.tar，可以写成 tar -f shiyanlou.tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件

解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）
$ mkdir tardir
$ tar -xf shiyanlou.tar -C tardir

只查看不解包文件 -t 参数：
$ tar -tf shiyanlou.tar

保留文件属性（-p 参数）和跟随链接（-h 参数）（符号链接或软链接）
$ tar -cphf etc.tar /etc

我们只需要在创建 tar 文件的基础上添加 -z 参数，使用 gzip 来压缩文件
$ tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop

解压 *.tar.gz 文件
$ tar -xzf shiyanlou.tar.gz

压缩文件格式	参数
*.tar.gz	-z
*.tar.xz	-J
*tar.bz2	-j

总结常用命令：
zip：
打包 ：zip something.zip something （目录请加 -r 参数）
解包：unzip something.zip
指定路径：-d 参数
tar：
打包：tar -cf something.tar something
解包：tar -xf something.tar
指定路径：-C 参数

Practice 7
1.2 df du mount 命令的使用；磁盘相关知识的学习
基本操作： 
df 查看磁盘容量
df -h 
使用du命令查看目录的容量
du  加上-h更易读

-d 查看目录深度
只看一级目录信息：du -h -d 0 ~
查看二级目录信息：du -h -d 1 ~

常用参数
du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。
du -a #同--all 显示目录中所有文件的大小。
du -s #同--summarize 仅显示总计，只列出最后加总的值。
来自: http://man.linuxde.net/du
三、简单的磁盘管理
初学者建议在虚拟环境中进行操作
3.1 创建虚拟磁盘
用dd命令从标准输入读入用户的输入到标准输出或者一个文件中
# 输出到文件
$ dd of=test bs=10 count=1 # 或者 dd if=/dev/stdin of=test bs=10 count=1
# 输出到标准输出
$ dd if=/dev/stdin of=/dev/stdout bs=10 count=1
# 注
在打完了这个命令后，继续在终端打字，作为你的输入

上述命令从标准输入设备读入用户输入（缺省值，所以可省略）然后输出到 test 文件，bs（block size）用于指定块大小（缺省单位为 Byte，也可为其指定如'K'，'M'，'G'等单位），count用于指定块数量。如上图所示，我指定只读取总共 10 个字节的数据，当我输入了“hello shiyanlou”之后加上空格回车总共 16 个字节（一个英文字符占一个字节）内容，显然超过了设定大小。使用du和cat命令看到的写入完成文件实际内容确实只有 10 个字节（那个黑底百分号表示这里没有换行符）,而其他的多余输入将被截取并保留在标准输入。

dd在拷贝的同时还可以实现数据转换，那下面就举一个简单的例子：将输出的英文字符转换为大写再写入文件：
$ dd if=/dev/stdin of=test bs=10 count=1 conv=ucase
可以在man文档中查看其他所有转换参数

使用 dd 命令创建虚拟镜像文件
从/dev/zero设备创建一个容量为 256M 的空文件
$ dd if=/dev/zero of=virtual.img bs=1M count=256
$ du -h virtual.img

使用 mkfs 命令格式化磁盘（我们这里是自己创建的虚拟磁盘镜像）：可以在命令行输入 sudo mkfs 然后按下Tab键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统
用下面的命令来将我们的虚拟磁盘镜像格式化为ext4文件系统
$ sudo mkfs.ext4 virtual.img

知道 Linux 支持哪些文件系统你可以输入ls -l /lib/modules/$(uname -r)/kernel/fs

使用 mount 命令挂载磁盘到目录树
Linux/UNIX 命令行的 mount 指令是告诉操作系统，对应的文件系统已经准备好，可以使用了，而该文件系统会对应到一个特定的点（称为挂载点）。挂载好的文件、目录、设备以及特殊文件即可提供用户使用。
$ sudo mount
输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）。

mount命令的一般格式如下：
mount [options] [source] [directory]

一些常用操作
mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]

挂载我们创建的虚拟磁盘镜像到/mnt目录：
$ mount -o loop -t ext4 virtual.img /mnt 
# 也可以省略挂载类型，很多时候 mount 会自动识别

# 以只读方式挂载
$ mount -o loop --ro virtual.img /mnt
# 或者mount -o loop,ro virtual.img /mnt

使用 umount 命令卸载已挂载磁盘
# 命令格式 sudo umount 已挂载设备名或者挂载点，如：
$ sudo umount /mnt

使用 fdisk 为磁盘分区
# 查看硬盘分区表信息
$ sudo fdisk -l

# 进入磁盘分区模式
$ sudo fdisk virtual.img
首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。

操作完成后输入p查看结果如下:
最后不要忘记输入w写入分区表

使用 losetup 命令建立镜像与回环设备的关联
$ sudo losetup /dev/loop0 virtual.img
# 如果提示设备忙你也可以使用其它的回环设备，"ls /dev/loop*"参看所有回环设备

# 解除设备关联
$ sudo losetup -d /dev/loop0

使用mkfs格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到kpartx工具，需要先安装
$ sudo apt-get install kpartx
$ sudo kpartx -av /dev/loop0

# 取消映射
$ sudo kpartx -dv /dev/loop0

接着再是格式化，我们将其全部格式化为 ext4
$ sudo mkfs.ext4 -q /dev/mapper/loop0p1
$ sudo mkfs.ext4 -q /dev/mapper/loop0p5
$ sudo mkfs.ext4 -q /dev/mapper/loop0p6

格式化完成后在/media目录下新建四个空目录用于挂载虚拟磁盘：
$ mkdir -p /media/virtualdisk_{1..3}
# 挂载磁盘分区
$ sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1
$ sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2
$ sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3

# 卸载磁盘分区
$ sudo umount /dev/mapper/loop0p1
$ sudo umount /dev/mapper/loop0p5
$ sudo umount /dev/mapper/loop0p6
然后：
$ df -h

轻松一下：
cowsay命令，可以让你在终端里以一种动物说话的形式打印出一段话
# 更新软件包
$ sudo apt update

# 安装
$ sudo apt install -y cowsay

# 默认是一只牛
$ cowsay hello shiyanlou

# 加上'-l'参数打印所有支持的动物（其实不只是动物）种类
$ cowsay -l

# 使用'-f'参数选择动物种类
$ cowsay -f elephant hello shiyanlou

# 安装 fortune-zh
$ sudo apt-get install fortune-zh

# 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用
$ /usr/games/fortune | cowsay -f daemon

实验8 Linux下的帮助命令
內建命令 外部命令 help man info 使用及区别
使用type命令来区分 
1、help命令
bash
help ls
显示错误，因为help适用于显示shell內建命令的简要帮助信息
ls --help
man ls

3.info 命令
info ls
info工具更完整

实验9 Linux任务计划crontab
crontab 语法
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed

2.2crontanb准备
启动rsyslog ，本地已经默认启动
sudo apt-get install -y rsyslog
sudo service rsyslog start

sudo cron －f &

2.3 crontab 使用
crontab -e
选择第二个基本的 vim 就可以了

详细的格式可以使用上一节中学习到的 man 命令查看:man crontab
在/home/shiyanlou目录下创建一个以当前的年月日时分秒为名字的空白文件
*/1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)
注意 “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转义，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。

2种方式来确定我们的 cron 是否成功的在后台启动，
ps aux | grep cron

or

pgrep cron

通过 ll 查看生成了多少

通过这样一个命令可以查看到执行任务命令之后在日志中的信息反馈
sudo tail -f /var/log/syslog

不需要可删除任务：crontab -r
三、crontab 的深入
每个用户使用 crontab -e 添加计划任务，都会在 /var/spool/cron/crontabs 中添加一个该用户自己的任务文档，这样目的是为了隔离。
如果是系统级别的定时任务，应该如何处理？只需要以 sudo 权限编辑 /etc/crontab 文件就可以。
cron 服务监测时间最小单位是分钟，所以 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron/crontabs 里面的內容。
每个目录的作用：

/etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行；
/etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行；
/etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行；
/etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；
系统默认执行时间可以根据需求进行修改。
挑战：备份日志
为 shiyanlou 用户添加计划任务
每天凌晨 3 点的时候定时备份 alternatives.log 到 /home/shiyanlou/tmp/ 目录
命名格式为 年-月-日，比如今天是2017年4月1日，那么文件名为 2017-04-01

sudo cron -f &
crontab -e 添加
0 3 * * * sudo rm /home/shiyanlou/tmp/*
0 3 * * * sudo cp /var/log/alternatives.log /home/shiyanlou/tmp/$(date +\%Y-\%m-\%d)

实验 10
命令执行顺序控制与管道
cut，grep，wc，sort命令的使用
管道的理解
2.1 顺序执行多条命令
之前：
$ sudo apt-get update
# 等待——————————然后输入下面的命令
$ sudo apt-get install some-tool //这里some-tool是指具体的软件包
# 等待——————————然后输入下面的命令
$ some-tool

现在：
$ sudo apt-get update;sudo apt-get install some-tool;some-tool
# 让它自己运行

2.2 有选择的执行命令
$ which cowsay>/dev/null && cowsay -f head-in ohch~
学习过 C 语言的用户应该知道在 C 语言里面&&表示逻辑与，而且还有一个||表示逻辑或，同样 Shell 也有一个||，它们的区别就在于，shell中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。||在这里就是与&&相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令：
$ which cowsay>/dev/null || echo "cowsay has not been install, please run 'sudo apt-get install cowsay' to install"

除了上述基本的使用之外，我们还可以结合着&&和||来实现一些操作，比如：
$ which cowsay>/dev/null && echo "exist" || echo "not exist"

三、管道
3.1 试用
查看/etc目录下有哪些文件和目录，使用ls命令来查看：
$ ls -al /etc

有太多内容，屏幕不能完全显示，这时候可以使用滚动条或快捷键滚动窗口来查看。不过这时候可以使用管道：
$ ls -al /etc | less
通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。

3.2 cut 命令，打印每一行的某一字段
$ cut /etc/passwd -d ':' -f 1,6

打印/etc/passwd文件中每一行的前N个字符：
# 前五个（包含第五个）
$ cut /etc/passwd -c -5
# 前五个之后的（包含第五个）
$ cut /etc/passwd -c 5-
# 第五个
$ cut /etc/passwd -c 5
# 2到5之间的（包含第五个）
$ cut /etc/passwd -c 2-5

3.3 grep 命令，在文本中或 stdin 中查找匹配字符串
grep命令的一般形式为：
grep [命令选项]... 用于匹配的表达式 [文件]...

搜索/home/shiyanlou目录下所有包含"shiyanlou"的文本文件，并显示出现在文本中的行号：
$ grep -rnI "shiyanlou" ~
-r 参数表示递归搜索子目录中的文件,-n表示打印匹配项行号，-I表示忽略二进制文件。这个操作实际没有多大意义，但可以感受到grep命令的强大与实用。

# 查看环境变量中以"yanlou"结尾的字符串
$ export | grep ".*yanlou$"
其中$就表示一行的末尾

3.4 wc 命令，简单小巧的计数工具
wc 命令用于统计并输出一个文件中行、单词和字节的数目，比如输出/etc/passwd文件的统计信息：
$ wc /etc/passwd

分别只输出行数、单词数、字节数、字符数和输入文本中最长一行的字节数：
# 行数
$ wc -l /etc/passwd
# 单词数
$ wc -w /etc/passwd
# 字节数
$ wc -c /etc/passwd
# 字符数
$ wc -m /etc/passwd
# 最长行字节数
$ wc -L /etc/passwd

结合管道来操作一下，下面统计 /etc 下面所有目录数：
$ ls -dl /etc/*/ | wc -l

3.5 sort 排序命令
默认为字典排序：
$ cat /etc/passwd | sort

反转排序：
$ cat /etc/passwd | sort -r

按特定字段排序：
$ cat /etc/passwd | sort -t':' -k 3
上面的-t参数用于指定字段的分隔符，这里是以":"作为分隔符；-k 字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：
$ cat /etc/passwd | sort -t':' -k 3 -n

3.6 uniq 去重命令
uniq命令可以用于过滤或者输出重复行。
过滤重复行
我们可以使用history命令查看最近执行过的命令（实际为读取${SHELL}_history文件,如我们环境中的~/.zsh_history文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：
$ history | cut -c 8- | cut -d ' ' -f 1 | uniq
然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为uniq命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq
# 或者$ history | cut -c 8- | cut -d ' ' -f 1 | sort -u
这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。

输出重复行
# 输出重复过的行（重复的只输出一个）及重复次数
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc
# 输出所有重复的行
$ history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D

shiyanlou:~/ $ sudo apt update
shiyanlou:~/ $ sudo apt install -y aview imagemagick 
shiyanlou:~/ $ wget http://labfile.oss.aliyuncs.com/courses/1/Linus.png
 asciiview [图片文件名] 即可打开图片
 
 实验 11  简单的文本处理
这一节我们将介绍这几个命令tr（注意不是tar），col，join，paste。实际这一节是上一节关于能实现管道操作的命令的延续，所以我们依然将结合管道来熟悉这些命令的使用。
2.1 tr 命令
tr 命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。
使用方式：
tr [option]...SET1 [SET2]
选项	说明
-d	删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配
-s	去除set1指定的在输入文本中连续并重复的字符

操作举例：
# 删除 "hello shiyanlou" 中所有的'o','l','h'
$ echo 'hello shiyanlou' | tr -d 'olh'
# 将"hello" 中的ll,去重为一个l
$ echo 'hello' | tr -s 'l'
# 将输入文本，全部转换为大写或小写输出
$ echo 'input some text here' | tr '[:lower:]' '[:upper:]'
# 上面的'[:lower:]' '[:upper:]'你也可以简单的写作'[a-z]' '[A-Z]',当然反过来将大写变小写也是可以的

更多 tr 的使用，你可以使用--help或者man tr获得。

2.2 col 命令
col 命令可以将Tab换成对等数量的空格键，或反转这个操作。
使用方式：
col [option]
常用的选项有：

选项	说明
-x	将Tab转换为空格
-h	将空格转换为Tab（默认选项）

操作举例：
# 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号
$ cat -A /etc/protocols
# 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看，你发现 ^I 不见了
$ cat /etc/protocols | col -x | cat -A

2.3 join
将两个文件中包含相同内容的那一行合并到一起
使用方式：
join [option]... file1 file2
常用的选项有：
选项    说明
-t      指定分隔符，默认为空格
-i      忽略大小写的差异
-1      指明第一个文件要用哪个字段来对比，默认对比第一个字段
-2      指明第二个文件要用哪个字段来对比，默认对比第一个字段

操作举例：
$ cd /home/shiyanlou
# 创建两个文件
$ echo '1 hello' > file1
$ echo '1 shiyanlou' > file2
$ join file1 file2
# 将/etc/passwd与/etc/shadow两个文件合并，指定以':'作为分隔符
$ sudo join -t':' /etc/passwd /etc/shadow
# 将/etc/passwd与/etc/group两个文件合并，指定以':'作为分隔符, 分别比对第4和第3个字段
$ sudo join -t':' -1 4 /etc/passwd -2 3 /etc/group

2.4 paste命令
paste这个命令与join 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。
使用方式：
paste [option] file...

常用的选项有：
选项	说明
-d	指定合并的分隔符，默认为Tab
-s	不合并到一行，每个文件为一行

操作举例：
$ echo hello > file1
$ echo shiyanlou > file2
$ echo www.shiyanlou.com > file3
$ paste -d ':' file1 file2 file3
$ paste -s file1 file2 file3
实验12 数据流重定向
两个重定向基本操作
echo ‘hello shiyanlou’ > redirect
echo 'www.shiyanlou.com' >> redirect
cat redirect

2.1 简单的重定向
stdin stdout stderr
文件描述符 设备文件 说明
0          /dev/stdin 标准输入
1          /dev/stdout 标准输出
2          /dev/stderr 标准错误

将cat的连续输出（heredoc方式）重定向到一个文件
mkdir Documents 
cat > Documents/test.c <<EOF
#include <stdin.h>
int main()
{
    printf("hello world\n");
    return 0;
}

EOF
将一个文件作为命令的输入，标准输出作为命令的输出
cat Documents/test.c
将echo命令通过管道传过来的数据作为cat命令的输入，将标准输出作为命令的输出
echo 'hi' |cat

将echo命令的输出从默认的标准输出重定向到一个普通文件
echo 'hello shiyanlou' > rediredct
cat redirect

2.2 标准错误重定向
#使用cat命令同是读取两个文件，其中一个存在，另一个不存在
cat Documents/test.c hello.c
#可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息
#下面我们将输出重定向到一个文件
cat Documents/test.c hello.c > somefile

隐藏错误或者警告
将标准错误重定向到标准输出，再将标准输出重定向到文件，注意要将
重定向到文件写到前面
cat Documents/test.c hello.c > somefile 2>&1
或者只用bash提供的特殊的重定向符号”&“将标准错误和标准输出同时
重定向到文件
cat Documents/test.c hello.c &>somefilehell

2.3 使用tee命令同时重定向到多个文件
echo 'hello shiyanlou' |tee hello

2.4 永久重定向 ：exec
#先开启一个子shell
zsh
#使用exec替换当前进程的重定向，将标准输出重定向到一个文件
exec 1>somefile
#后面你执行的命令的输出都将被重定向到文件中，直到你退出当前子shell，
或取消exec的重定向
ls
exit
cat somefile

2.5 创建文件描述符
查看当前shell进程中的打开的文件描述符
cd /dev/fd/ ; ls -AL

使用exec命令可以创建新的文件描述符
zsh
exec 3>somefile
#先进入目录，在查看，否则你可能不能得到正确的结果，
然后再回到上一次的目录
cd /dev/fd/;ls -AL;cd -
#注意下面的命令>与&之间不应搞有空格
echo "this is test" >&3
cat somefile 
exit

2.6 关闭文件描述符
exec 3>&-
cd /dev/fd;ls -Al;cd -

2.7 完全屏蔽命令的输出
cat Documents/test.c 1>/dev/null 2>&1

2.8 使用xargs 分割参数列表
cut -d: -fl < /etc/passwd | sort | xargs echo
上面这个命令用于将/etc/passwd 文件按： 分割取第一个字段排序后，
使用echo命令生成一个列表

轻松一下
sudo apt-get install caca-utils
cacaview <pic_file>
cacademo
cacafire


实验13 正则表达式基础
1.1 实验内容
grep sed awk 三个命令
2.1 举例
shi*

2.2基本语法
选择：|
boy|girl可以匹配boy 或者 girl

数量限定
+ 表示前面的字符必须出现至少一次（一次或者多次）
如：goo+gle 可以匹配goooogle

？表示前面的字符最多出现一次（0次或1次）
如：colou?r 可以匹配 colour 或 color

*号代表前面的字符可以不出现，也可以出现一次或者多次（0次，或1次，或多次）
如：0*42 可以匹配 42、042、0042、00042

范围和优先级

()圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。
例如，"gr(a|e)y"等价于"gray|grey"，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），
"(grand)?father"匹配father和grandfather（这里体现了范围，?将圆括号内容作为一个整体匹配）。

语法（部分）
正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或
egrep的正则表达式匹配规则：(由于markdown表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用
时请换回半角字符)

字符	 描述
\	    将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。
      序列“\\”匹配“\”而“\(”则匹配“(”。
^	    匹配输入字符串的开始位置。
$	    匹配输入字符串的结束位置。
{n}	  n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。
{n,}	 n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。
       “o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。
{n,m}	m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的
      前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。
*	     匹配前面的子表达式零次或多次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}。
+	     匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。
?	     匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。
?	     当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式
尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配
单个“o”，而“o+”将匹配所有“o”。
.	     匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。
(pattern)	匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“\(”或“\)”。
x｜y	    匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。
[xyz]	   字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符
仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示
负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果出现在首位则仅
作为普通字符。
[^xyz]	   排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。
[a-z]	    字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。
[^a-z]	   排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。

优先级
优先级为从上到下从左到右，依次降低：

运算符                    	说明
\	                        转义符
(), (?:), (?=), []	       括号和中括号
*、+、?、{n}、{n,}、{n,m}  	限定符
^、$、\                    任何元字符	定位点和序列
｜	                        选择

3.1 基本操作
grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定：
参数	说明
-E	POSIX扩展正则表达式，ERE
-G	POSIX基本正则表达式，BRE
-P	Perl正则表达式，PCRE

grep常用参数

参数	说明
-b	     将二进制文件作为文本来进行匹配
-c	     统计以模式匹配的数目
-i	     忽略大小写
-n	     显示匹配文本所在行的行号
-v	     反选，输出不匹配行的内容
-r	     递归匹配查找
-A n	   n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行
-B n	   n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行
--color=auto	将输出中的匹配项设置为自动颜色显示
注：在大多数发行版中是默认设置了grep的颜色的，你可以通过参数指定或修改GREP_COLOR环境变量。

3.2 使用正则表达式
使用基本正则表达式，BRE
位置
查找/etc/group文件中以"shiyanlou"为开头的行
$ grep 'shiyanlou' /etc/group
$ grep '^shiyanlou' /etc/group

数量
# 将匹配以'z'开头以'o'结尾的所有字符串
$ echo 'zero\nzo\nzoo' | grep 'z.*o'
# 将匹配以'z'开头以'o'结尾，中间包含一个任意字符的字符串
$ echo 'zero\nzo\nzoo' | grep 'z.o'
# 将匹配以'z'开头,以任意多个'o'结尾的字符串
$ echo 'zero\nzo\nzoo' | grep 'zo*'

注意：其中\n为换行符

选择
# grep默认是区分大小写的，这里将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[a-z]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[0-9]'
# 将匹配所有的数字
$ echo '1234\nabcd' | grep '[[:digit:]]'
# 将匹配所有的小写字母
$ echo '1234\nabcd' | grep '[[:lower:]]'
# 将匹配所有的大写字母
$ echo '1234\nabcd' | grep '[[:upper:]]'
# 将匹配所有的字母和数字，包括0-9,a-z,A-Z
$ echo '1234\nabcd' | grep '[[:alnum:]]'
# 将匹配所有的字母
$ echo '1234\nabcd' | grep '[[:alpha:]]'

完整的特殊符号及说明：
特殊符号	说明
[:alnum:]	代表英文大小写字母及数字，亦即 0-9, A-Z, a-z
[:alpha:]	代表任何英文大小写字母，亦即 A-Z, a-z
[:blank:]	代表空白键与 [Tab] 按键两者
[:cntrl:]	代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
[:digit:]	代表数字而已，亦即 0-9
[:graph:]	除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
[:lower:]	代表小写字母，亦即 a-z
[:print:]	代表任何可以被列印出来的字符
[:punct:]	代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...
[:upper:]	代表大写字母，亦即 A-Z
[:space:]	任何会产生空白的字符，包括空白键, [Tab], CR 等等
[:xdigit:]	代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节
注意：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，"a A b B...z Z"，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。

# 排除字符
$ $ echo 'geek\ngood' | grep '[^o]'
注意:当^放到中括号内为排除字符，否则表示行首。

使用扩展正则表达式，ERE
要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。
数量
# 只匹配"zo"
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1}'
# 匹配以"zo"开头的所有单词
$ echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'
注意：推荐掌握{n,m}即可，+,?,*，这几个不太直观，且容易弄混淆。

选择
# 匹配"www.shiyanlou.com"和"www.google.com"
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -E 'www\.(shiyanlou|google)\.com'
# 或者匹配不包含"baidu"的内容
$ echo 'www.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -Ev 'www\.baidu\.com'
注意：因为.号有特殊含义，所以需要转义。



